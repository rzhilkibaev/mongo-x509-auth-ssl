#!/usr/bin/env bash
#
# This script creates all necessary keys and certificates.
# If you execute this script all existing files are going
# to be overwritten with new ones and existing clients will no longer work.

set -eo pipefail

# Generated files
# CA pem file (private key + x509 cert)
CA_PEM=mongodb-CA.pem
# Server pem file (private key + x509 cert)
SRV_PEM=mongodb-server.pem
# Client pem file (private key + x509 cert)
CLIENT_PEM=mongodb-client.pem
# JKS store with CA x509 cert in it
CA_JKS=mongodb-CA.jks
# Client JKS type store with client private key and certificate in it
CLIENT_JKS=mongodb-client.jks

# Temp files
# CA (Certificate Authority) private key
CA_KEY=mongodb-CA.key
# CA x509 certificate
CA_CRT=mongodb-CA.crt
# CA serial file (autogenerated)
CA_SRL=mongodb-CA.srl
# Server private key
SRV_KEY=mongodb-server.key
# Server x509 certificate
SRV_CRT=mongodb-server.crt
# Server CSR file (Certificate Signing Request)
SRV_CSR=mongodb-server.csr
# Client private key
CLIENT_KEY=mongodb-client.key
# Client x509 certificate
CLIENT_CRT=mongodb-client.crt
# Client CSR file
CLIENT_CSR=mongodb-client.csr
# Client PKCS12 type store with client private key and certificate in it
CLIENT_P12=mongodb-client.p12

# common subj part
SUBJ_PART='/OU=JSDev/O=Jaspersoft/L=San Francisco/ST=CA/C=US'
# Certification Authority certificate subj
CA_SUBJ="/CN=CA$SUBJ_PART"
# Server certificate subj, the CN must match the hosname of the server
SRV_SUBJ="/CN=127.0.0.1$SUBJ_PART"
# Client certificate subj
CLIENT_SUBJ="/CN=admin$SUBJ_PART"

# Using self-signed certificates.
# The first step is to create private and public key and wrap the public key into a x509 certificate, signing it with the private key.
# This generates the private key (.key) and certificate (.crt) files. The certificate is going to be our CA (Certification Authority).
# We'll use this root certificate to signt server and client certificates.
#
# This cone command creates private key and self-signed x509 certificate
openssl req -newkey rsa:2048 -new -x509 -extensions v3_ca -days 9999 -nodes -out $CA_CRT -keyout $CA_KEY -subj "$CA_SUBJ"
# Concatenate the private key and the certificate into a pem file which will be used by mongod and mongo.
cat $CA_KEY $CA_CRT > $CA_PEM

# Now that we have CA.key, CA.crt and CA.pem we can create server private and public key.
# And wrap the public key into a x509 certificate, signing it with the root CA.crt we created earlier.
# This will prove server identity to the client and enable SSL.

# Create server private key and CSR (certificate signing request).
openssl req -new -nodes -newkey rsa:2048 -keyout $SRV_KEY -out $SRV_CSR -subj "$SRV_SUBJ"
# Now we have server private key (.key) and server certificate signing request (.csr).
# Use CA.key and CA.crt to sign  the server .csr file. This command will also generate a serial file (.srl)
# This is a file with a random number which is incremented each time CA.crt is used to sign something.
openssl x509 -CA $CA_CRT -CAkey $CA_KEY -CAcreateserial -req -days 9999 -in $SRV_CSR -out $SRV_CRT
# Concatentate the server private key and certificate into a pem file which will be used by mongod.
cat $SRV_KEY $SRV_CRT > $SRV_PEM
# Remove server .csr file, we won't need it anymore.
rm $SRV_CSR

# Now we have server private key (.key), x509 certificate (.crt) and pem file.

# Now generate client files the same way.
openssl req -new -nodes -newkey rsa:2048 -keyout $CLIENT_KEY -out $CLIENT_CSR -subj "$CLIENT_SUBJ"
openssl x509 -CA $CA_CRT -CAkey $CA_KEY -CAcreateserial -req -days 9999 -in $CLIENT_CSR -out $CLIENT_CRT
# Create pem file to be used by mongo.
cat $CLIENT_KEY $CLIENT_CRT > $CLIENT_PEM
rm $CLIENT_CSR

# Now we have client private key (.key), x509 certificate (.crt) and pem file.

# At this point the files can be used by the mongod and mongo.
# $ mongod --sslMode requireSSL --sslPEMKeyFile server.pem --sslCAFile CA.pem --auth --clusterAuthMode x509
# $ mongo admin --authenticationDatabase '$external' --ssl --sslPEMKeyFile mongodb-client.pem --sslCAFile mongodb-CA.pem --authenticationMechanism MONGODB-X509 -u "C=US,ST=CA,L=San Francisco,O=Jaspersoft,OU=JSDev,CN=admin"
# Note the reverse order of elements in the subj (I don't know why).

# Now for the java client we need to create trust-store.jks with CA.crt in it and key-store.jks with client.key and client.crt in it.

# Create JKS type trust store with CA cert in it.
keytool -importcert -trustcacerts -noprompt -file $CA_CRT -keystore $CA_JKS -storepass '123456'

# Create intermediate PKCS12 type store with client cert and key (I couldn't find another way to import client cert and key into JKS store).
openssl pkcs12 -export -in $CLIENT_CRT -inkey $CLIENT_KEY -chain -CAfile $CA_PEM -out $CLIENT_P12 -password pass:123456
# create JKS type key store with client cert and key
keytool -importkeystore -deststorepass '123456' -srcstorepass '123456' -destkeystore $CLIENT_JKS -srckeystore $CLIENT_P12 -srcstoretype PKCS12
# Won't need the .p12 file anymore.
rm $CLIENT_P12
# Won't need these eighter.
rm $CA_KEY $CA_CRT $SRV_KEY $SRV_CRT $CLIENT_KEY $CLIENT_CRT $CA_SRL

echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
echo "Created:"
echo "CA PEM file with the private key and self-signed certificate in it: $CA_PEM"
echo "Server PEM file with the private key and certificate signed by CA: $SRV_PEM"
echo "Client PEM file with the private key and certificate signed by CA: $CLIENT_PEM"
echo "Client JKS type trust store with CA sefl-signed certificate in it: $CA_JKS"
echo "Client JKS type key store with client private key and certifcate in it: $CLIENT_JKS"
echo "Done!"
